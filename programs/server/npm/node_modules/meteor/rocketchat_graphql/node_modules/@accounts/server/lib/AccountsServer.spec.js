'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _jwtDecode = require('jwt-decode');

var _jwtDecode2 = _interopRequireDefault(_jwtDecode);

var _AccountsServer = require('./AccountsServer');

var _AccountsServer2 = _interopRequireDefault(_AccountsServer);

var _encryption = require('./encryption');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

describe('Accounts', function () {
  beforeEach(function () {
    _AccountsServer2.default.config({}, {});
  });
  describe('config', function () {
    beforeEach(function () {});
    it('requires a db driver', function () {
      try {
        _AccountsServer2.default.config();
      } catch (err) {
        var message = err.message;

        expect(message).toEqual('A database driver is required');
      }
    });

    it('sets the db driver', function () {
      var db = {};
      _AccountsServer2.default.config({}, db);
      expect(_AccountsServer2.default.instance.db).toEqual(db);
    });

    it('set custom password authenticator', function () {
      var db = {};
      _AccountsServer2.default.config({ passwordAuthenticator: function passwordAuthenticator() {} }, db);
      expect(_AccountsServer2.default.instance.options.passwordAuthenticator).toBeDefined();
    });

    it('use default password authenticator', function () {
      var db = {};
      _AccountsServer2.default.config({}, db);
      expect(_AccountsServer2.default.instance.options.passwordAuthenticator).toBeUndefined();
    });
  });
  var db = {
    findUserByUsername: function findUserByUsername() {
      return Promise.resolve();
    },
    findUserByEmail: function findUserByEmail() {
      return Promise.resolve();
    },
    createUser: function createUser() {
      return Promise.resolve();
    },
    createSession: function createSession() {
      return Promise.resolve();
    }
  };
  describe('createUser', function () {
    beforeEach(function () {
      _AccountsServer2.default.config({}, db);
    });
    it('requires username or an email', _asyncToGenerator(regeneratorRuntime.mark(function _callee() {
      var message;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _AccountsServer2.default.config({}, db);
              _context.prev = 1;
              _context.next = 4;
              return _AccountsServer2.default.createUser({
                password: '123456',
                username: '',
                email: ''
              });

            case 4:
              throw new Error();

            case 7:
              _context.prev = 7;
              _context.t0 = _context['catch'](1);
              message = _context.t0.message;

              expect(message).toEqual('Username or Email is required');

            case 11:
            case 'end':
              return _context.stop();
          }
        }
      }, _callee, undefined, [[1, 7]]);
    })));
    it('throws error if username exists', _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {
      var message;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _AccountsServer2.default.config({}, _extends({}, db, {
                findUserByUsername: function findUserByUsername() {
                  return Promise.resolve('user');
                }
              }));
              _context2.prev = 1;
              _context2.next = 4;
              return _AccountsServer2.default.createUser({
                password: '123456',
                username: 'user1',
                email: ''
              });

            case 4:
              throw new Error();

            case 7:
              _context2.prev = 7;
              _context2.t0 = _context2['catch'](1);
              message = _context2.t0.message;

              expect(message).toEqual('Username already exists');

            case 11:
            case 'end':
              return _context2.stop();
          }
        }
      }, _callee2, undefined, [[1, 7]]);
    })));
    it('throws error if email exists', _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {
      var message;
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _AccountsServer2.default.config({}, _extends({}, db, {
                findUserByEmail: function findUserByEmail() {
                  return Promise.resolve('user');
                }
              }));
              _context3.prev = 1;
              _context3.next = 4;
              return _AccountsServer2.default.createUser({
                password: '123456',
                username: '',
                email: 'email1'
              });

            case 4:
              throw new Error();

            case 7:
              _context3.prev = 7;
              _context3.t0 = _context3['catch'](1);
              message = _context3.t0.message;

              expect(message).toEqual('Email already exists');

            case 11:
            case 'end':
              return _context3.stop();
          }
        }
      }, _callee3, undefined, [[1, 7]]);
    })));
    it('succesfully create a user', _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {
      var userId;
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              _AccountsServer2.default.config({}, _extends({}, db, {
                createUser: function createUser() {
                  return Promise.resolve('123');
                }
              }));
              _context4.next = 3;
              return _AccountsServer2.default.createUser({
                password: '123456',
                username: 'user1'
              });

            case 3:
              userId = _context4.sent;

              expect(userId).toEqual('123');

            case 5:
            case 'end':
              return _context4.stop();
          }
        }
      }, _callee4, undefined);
    })));
  });
  describe('loginWithPassword - errors', function () {
    it('throws error if user is undefined', _asyncToGenerator(regeneratorRuntime.mark(function _callee5() {
      var message;
      return regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              _context5.prev = 0;
              _context5.next = 3;
              return _AccountsServer2.default.loginWithPassword(null, '123456');

            case 3:
              throw new Error();

            case 6:
              _context5.prev = 6;
              _context5.t0 = _context5['catch'](0);
              message = _context5.t0.message;

              expect(message).toEqual('Unrecognized options for login request');

            case 10:
            case 'end':
              return _context5.stop();
          }
        }
      }, _callee5, undefined, [[0, 6]]);
    })));
    it('throws error if password is undefined', _asyncToGenerator(regeneratorRuntime.mark(function _callee6() {
      var message;
      return regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _context6.prev = 0;
              _context6.next = 3;
              return _AccountsServer2.default.loginWithPassword('username', null);

            case 3:
              throw new Error();

            case 6:
              _context6.prev = 6;
              _context6.t0 = _context6['catch'](0);
              message = _context6.t0.message;

              expect(message).toEqual('Unrecognized options for login request');

            case 10:
            case 'end':
              return _context6.stop();
          }
        }
      }, _callee6, undefined, [[0, 6]]);
    })));
    it('throws error if user is not a string or an object', _asyncToGenerator(regeneratorRuntime.mark(function _callee7() {
      var message;
      return regeneratorRuntime.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _context7.prev = 0;
              _context7.next = 3;
              return _AccountsServer2.default.loginWithPassword(1, '123456');

            case 3:
              throw new Error();

            case 6:
              _context7.prev = 6;
              _context7.t0 = _context7['catch'](0);
              message = _context7.t0.message;

              expect(message).toEqual('Match failed');

            case 10:
            case 'end':
              return _context7.stop();
          }
        }
      }, _callee7, undefined, [[0, 6]]);
    })));
    it('throws error if password is not a string', _asyncToGenerator(regeneratorRuntime.mark(function _callee8() {
      var message;
      return regeneratorRuntime.wrap(function _callee8$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              _context8.prev = 0;
              _context8.next = 3;
              return _AccountsServer2.default.loginWithPassword('username', {});

            case 3:
              throw new Error();

            case 6:
              _context8.prev = 6;
              _context8.t0 = _context8['catch'](0);
              message = _context8.t0.message;

              expect(message).toEqual('Match failed');

            case 10:
            case 'end':
              return _context8.stop();
          }
        }
      }, _callee8, undefined, [[0, 6]]);
    })));
    it('throws error if user is not found', _asyncToGenerator(regeneratorRuntime.mark(function _callee9() {
      var message;
      return regeneratorRuntime.wrap(function _callee9$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              _AccountsServer2.default.config({}, {
                findUserByUsername: function findUserByUsername() {
                  return Promise.resolve(null);
                },
                findUserByEmail: function findUserByEmail() {
                  return Promise.resolve(null);
                }
              });
              _context9.prev = 1;
              _context9.next = 4;
              return _AccountsServer2.default.loginWithPassword('username', '123456');

            case 4:
              throw new Error();

            case 7:
              _context9.prev = 7;
              _context9.t0 = _context9['catch'](1);
              message = _context9.t0.message;

              expect(message).toEqual('User not found');

            case 11:
            case 'end':
              return _context9.stop();
          }
        }
      }, _callee9, undefined, [[1, 7]]);
    })));
    it('throws error if password not set', _asyncToGenerator(regeneratorRuntime.mark(function _callee10() {
      var message;
      return regeneratorRuntime.wrap(function _callee10$(_context10) {
        while (1) {
          switch (_context10.prev = _context10.next) {
            case 0:
              _AccountsServer2.default.config({}, {
                findUserByUsername: function findUserByUsername() {
                  return Promise.resolve('123');
                },
                findUserByEmail: function findUserByEmail() {
                  return Promise.resolve(null);
                },
                findPasswordHash: function findPasswordHash() {
                  return Promise.resolve(null);
                }
              });
              _context10.prev = 1;
              _context10.next = 4;
              return _AccountsServer2.default.loginWithPassword('username', '123456');

            case 4:
              throw new Error();

            case 7:
              _context10.prev = 7;
              _context10.t0 = _context10['catch'](1);
              message = _context10.t0.message;

              expect(message).toEqual('User has no password set');

            case 11:
            case 'end':
              return _context10.stop();
          }
        }
      }, _callee10, undefined, [[1, 7]]);
    })));
    it('throws error if password is incorrect', _asyncToGenerator(regeneratorRuntime.mark(function _callee11() {
      var message;
      return regeneratorRuntime.wrap(function _callee11$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              _AccountsServer2.default.config({}, {
                findUserByUsername: function findUserByUsername() {
                  return Promise.resolve('123');
                },
                findUserByEmail: function findUserByEmail() {
                  return Promise.resolve(null);
                },
                findPasswordHash: function findPasswordHash() {
                  return Promise.resolve('hash');
                },
                verifyPassword: function verifyPassword() {
                  return Promise.resolve(false);
                }
              });
              _context11.prev = 1;
              _context11.next = 4;
              return _AccountsServer2.default.loginWithPassword('username', '123456');

            case 4:
              throw new Error();

            case 7:
              _context11.prev = 7;
              _context11.t0 = _context11['catch'](1);
              message = _context11.t0.message;

              expect(message).toEqual('Incorrect password');

            case 11:
            case 'end':
              return _context11.stop();
          }
        }
      }, _callee11, undefined, [[1, 7]]);
    })));
    it('should use custom password authenticator when specified', _asyncToGenerator(regeneratorRuntime.mark(function _callee12() {
      var user, authenticator, result;
      return regeneratorRuntime.wrap(function _callee12$(_context12) {
        while (1) {
          switch (_context12.prev = _context12.next) {
            case 0:
              user = {
                id: '123',
                username: 'username',
                email: 'email@email.com',
                profile: {
                  bio: 'bio'
                }
              };
              authenticator = jest.fn(function () {
                return Promise.resolve(user);
              });


              _AccountsServer2.default.config({ passwordAuthenticator: authenticator }, db);

              _context12.next = 5;
              return _AccountsServer2.default.loginWithPassword('username', '123456');

            case 5:
              result = _context12.sent;


              expect(result).toBeDefined();
              expect(authenticator.mock.calls.length).toEqual(1);

            case 8:
            case 'end':
              return _context12.stop();
          }
        }
      }, _callee12, undefined);
    })));
    describe('loginWithUser', function () {
      it('login using id', _asyncToGenerator(regeneratorRuntime.mark(function _callee13() {
        var hash, user, findUserById, res, _res$tokens, accessToken, refreshToken, decodedAccessToken;

        return regeneratorRuntime.wrap(function _callee13$(_context13) {
          while (1) {
            switch (_context13.prev = _context13.next) {
              case 0:
                hash = (0, _encryption.hashPassword)('1234567');
                user = {
                  id: '123',
                  username: 'username',
                  email: 'email@email.com',
                  profile: {
                    bio: 'bio'
                  }
                };
                findUserById = jest.fn(function () {
                  return Promise.resolve(user);
                });

                _AccountsServer2.default.config({}, {
                  findUserById: findUserById,
                  findPasswordHash: function findPasswordHash() {
                    return Promise.resolve(hash);
                  },
                  createSession: function createSession() {
                    return Promise.resolve('sessionId');
                  }
                });
                _context13.next = 6;
                return _AccountsServer2.default.loginWithPassword({ id: '123' }, '1234567');

              case 6:
                res = _context13.sent;

                expect(findUserById.mock.calls[0][0]).toEqual('123');
                expect(res.user).toEqual(user);
                _res$tokens = res.tokens, accessToken = _res$tokens.accessToken, refreshToken = _res$tokens.refreshToken;
                decodedAccessToken = (0, _jwtDecode2.default)(accessToken);

                expect(decodedAccessToken.data.sessionId).toEqual('sessionId');
                expect(accessToken).toBeTruthy();
                expect(refreshToken).toBeTruthy();

              case 14:
              case 'end':
                return _context13.stop();
            }
          }
        }, _callee13, undefined);
      })));
    });
    describe('refreshTokens', function () {
      it('updates session and returns new tokens and user', _asyncToGenerator(regeneratorRuntime.mark(function _callee14() {
        var updateSession, user, _Accounts$instance$cr, accessToken, refreshToken, res;

        return regeneratorRuntime.wrap(function _callee14$(_context14) {
          while (1) {
            switch (_context14.prev = _context14.next) {
              case 0:
                updateSession = jest.fn(function () {
                  return Promise.resolve();
                });
                user = {
                  userId: '123',
                  username: 'username'
                };

                _AccountsServer2.default.config({}, {
                  findSessionById: function findSessionById() {
                    return Promise.resolve({
                      sessionId: '456',
                      valid: true,
                      userId: '123'
                    });
                  },
                  findUserById: function findUserById() {
                    return Promise.resolve(user);
                  },
                  updateSession: updateSession
                });
                _Accounts$instance$cr = _AccountsServer2.default.instance.createTokens('456'), accessToken = _Accounts$instance$cr.accessToken, refreshToken = _Accounts$instance$cr.refreshToken;

                _AccountsServer2.default.instance.createTokens = function () {
                  return {
                    accessToken: 'newAccessToken',
                    refreshToken: 'newRefreshToken'
                  };
                };
                _context14.next = 7;
                return _AccountsServer2.default.refreshTokens(accessToken, refreshToken, 'ip', 'user agent');

              case 7:
                res = _context14.sent;

                expect(updateSession.mock.calls[0]).toEqual(['456', 'ip', 'user agent']);
                expect(res.user).toEqual({
                  userId: '123',
                  username: 'username'
                });

              case 10:
              case 'end':
                return _context14.stop();
            }
          }
        }, _callee14, undefined);
      })));

      it('requires access and refresh tokens', _asyncToGenerator(regeneratorRuntime.mark(function _callee15() {
        return regeneratorRuntime.wrap(function _callee15$(_context15) {
          while (1) {
            switch (_context15.prev = _context15.next) {
              case 0:
                _AccountsServer2.default.config({}, {});
                _context15.prev = 1;
                _context15.next = 4;
                return _AccountsServer2.default.refreshTokens();

              case 4:
                throw new Error();

              case 7:
                _context15.prev = 7;
                _context15.t0 = _context15['catch'](1);

                expect(_context15.t0.message).toEqual('An accessToken and refreshToken are required');

              case 10:
              case 'end':
                return _context15.stop();
            }
          }
        }, _callee15, undefined, [[1, 7]]);
      })));
      it('throws error if tokens are not valid', _asyncToGenerator(regeneratorRuntime.mark(function _callee16() {
        return regeneratorRuntime.wrap(function _callee16$(_context16) {
          while (1) {
            switch (_context16.prev = _context16.next) {
              case 0:
                _AccountsServer2.default.config({}, {});
                _context16.prev = 1;
                _context16.next = 4;
                return _AccountsServer2.default.refreshTokens('bad access token', 'bad refresh token');

              case 4:
                throw new Error();

              case 7:
                _context16.prev = 7;
                _context16.t0 = _context16['catch'](1);

                expect(_context16.t0.message).toEqual('Tokens are not valid');

              case 10:
              case 'end':
                return _context16.stop();
            }
          }
        }, _callee16, undefined, [[1, 7]]);
      })));
      it('throws error if session not found', _asyncToGenerator(regeneratorRuntime.mark(function _callee17() {
        var _Accounts$instance$cr2, accessToken, refreshToken;

        return regeneratorRuntime.wrap(function _callee17$(_context17) {
          while (1) {
            switch (_context17.prev = _context17.next) {
              case 0:
                _AccountsServer2.default.config({}, {
                  findSessionById: function findSessionById() {
                    return Promise.resolve(null);
                  }
                });
                _context17.prev = 1;
                _Accounts$instance$cr2 = _AccountsServer2.default.instance.createTokens(), accessToken = _Accounts$instance$cr2.accessToken, refreshToken = _Accounts$instance$cr2.refreshToken;
                _context17.next = 5;
                return _AccountsServer2.default.refreshTokens(accessToken, refreshToken);

              case 5:
                throw new Error();

              case 8:
                _context17.prev = 8;
                _context17.t0 = _context17['catch'](1);

                expect(_context17.t0.message).toEqual('Session not found');

              case 11:
              case 'end':
                return _context17.stop();
            }
          }
        }, _callee17, undefined, [[1, 8]]);
      })));
      it('throws error if session not valid', _asyncToGenerator(regeneratorRuntime.mark(function _callee18() {
        var _Accounts$instance$cr3, accessToken, refreshToken;

        return regeneratorRuntime.wrap(function _callee18$(_context18) {
          while (1) {
            switch (_context18.prev = _context18.next) {
              case 0:
                _AccountsServer2.default.config({}, {
                  findSessionById: function findSessionById() {
                    return Promise.resolve({
                      valid: false
                    });
                  }
                });
                _context18.prev = 1;
                _Accounts$instance$cr3 = _AccountsServer2.default.instance.createTokens(), accessToken = _Accounts$instance$cr3.accessToken, refreshToken = _Accounts$instance$cr3.refreshToken;
                _context18.next = 5;
                return _AccountsServer2.default.refreshTokens(accessToken, refreshToken);

              case 5:
                throw new Error();

              case 8:
                _context18.prev = 8;
                _context18.t0 = _context18['catch'](1);

                expect(_context18.t0.message).toEqual('Session is no longer valid');

              case 11:
              case 'end':
                return _context18.stop();
            }
          }
        }, _callee18, undefined, [[1, 8]]);
      })));
    });
    describe('logout', function () {
      it('invalidates session', _asyncToGenerator(regeneratorRuntime.mark(function _callee19() {
        var invalidateSession, user, _Accounts$instance$cr4, accessToken;

        return regeneratorRuntime.wrap(function _callee19$(_context19) {
          while (1) {
            switch (_context19.prev = _context19.next) {
              case 0:
                invalidateSession = jest.fn(function () {
                  return Promise.resolve();
                });
                user = {
                  userId: '123',
                  username: 'username'
                };

                _AccountsServer2.default.config({}, {
                  findSessionById: function findSessionById() {
                    return Promise.resolve({
                      sessionId: '456',
                      valid: true,
                      userId: '123'
                    });
                  },
                  findUserById: function findUserById() {
                    return Promise.resolve(user);
                  },
                  invalidateSession: invalidateSession
                });
                _Accounts$instance$cr4 = _AccountsServer2.default.instance.createTokens('456'), accessToken = _Accounts$instance$cr4.accessToken;
                _context19.next = 6;
                return _AccountsServer2.default.logout(accessToken);

              case 6:
                expect(invalidateSession.mock.calls[0]).toEqual(['456']);

              case 7:
              case 'end':
                return _context19.stop();
            }
          }
        }, _callee19, undefined);
      })));
    });
    describe('findSessionByAccessToken', function () {
      it('requires access token', _asyncToGenerator(regeneratorRuntime.mark(function _callee20() {
        return regeneratorRuntime.wrap(function _callee20$(_context20) {
          while (1) {
            switch (_context20.prev = _context20.next) {
              case 0:
                _AccountsServer2.default.config({}, {});
                _context20.prev = 1;
                _context20.next = 4;
                return _AccountsServer2.default.logout();

              case 4:
                throw new Error();

              case 7:
                _context20.prev = 7;
                _context20.t0 = _context20['catch'](1);

                expect(_context20.t0.message).toEqual('An accessToken is required');

              case 10:
              case 'end':
                return _context20.stop();
            }
          }
        }, _callee20, undefined, [[1, 7]]);
      })));
      it('throws error if tokens are not valid', _asyncToGenerator(regeneratorRuntime.mark(function _callee21() {
        return regeneratorRuntime.wrap(function _callee21$(_context21) {
          while (1) {
            switch (_context21.prev = _context21.next) {
              case 0:
                _AccountsServer2.default.config({}, {});
                _context21.prev = 1;
                _context21.next = 4;
                return _AccountsServer2.default.logout('bad access token');

              case 4:
                throw new Error();

              case 7:
                _context21.prev = 7;
                _context21.t0 = _context21['catch'](1);

                expect(_context21.t0.message).toEqual('Tokens are not valid');

              case 10:
              case 'end':
                return _context21.stop();
            }
          }
        }, _callee21, undefined, [[1, 7]]);
      })));
      it('throws error if session not found', _asyncToGenerator(regeneratorRuntime.mark(function _callee22() {
        var _Accounts$instance$cr5, accessToken;

        return regeneratorRuntime.wrap(function _callee22$(_context22) {
          while (1) {
            switch (_context22.prev = _context22.next) {
              case 0:
                _AccountsServer2.default.config({}, {
                  findSessionById: function findSessionById() {
                    return Promise.resolve(null);
                  }
                });
                _context22.prev = 1;
                _Accounts$instance$cr5 = _AccountsServer2.default.instance.createTokens(), accessToken = _Accounts$instance$cr5.accessToken;
                _context22.next = 5;
                return _AccountsServer2.default.logout(accessToken);

              case 5:
                throw new Error();

              case 8:
                _context22.prev = 8;
                _context22.t0 = _context22['catch'](1);

                expect(_context22.t0.message).toEqual('Session not found');

              case 11:
              case 'end':
                return _context22.stop();
            }
          }
        }, _callee22, undefined, [[1, 8]]);
      })));
      it('throws error if session not valid', _asyncToGenerator(regeneratorRuntime.mark(function _callee23() {
        var _Accounts$instance$cr6, accessToken;

        return regeneratorRuntime.wrap(function _callee23$(_context23) {
          while (1) {
            switch (_context23.prev = _context23.next) {
              case 0:
                _AccountsServer2.default.config({}, {
                  findSessionById: function findSessionById() {
                    return Promise.resolve({
                      valid: false
                    });
                  }
                });
                _context23.prev = 1;
                _Accounts$instance$cr6 = _AccountsServer2.default.instance.createTokens(), accessToken = _Accounts$instance$cr6.accessToken;
                _context23.next = 5;
                return _AccountsServer2.default.logout(accessToken);

              case 5:
                throw new Error();

              case 8:
                _context23.prev = 8;
                _context23.t0 = _context23['catch'](1);

                expect(_context23.t0.message).toEqual('Session is no longer valid');

              case 11:
              case 'end':
                return _context23.stop();
            }
          }
        }, _callee23, undefined, [[1, 8]]);
      })));
    });
    describe('resumeSession', function () {
      it('return user', _asyncToGenerator(regeneratorRuntime.mark(function _callee24() {
        var user, _Accounts$instance$cr7, accessToken, foundUser;

        return regeneratorRuntime.wrap(function _callee24$(_context24) {
          while (1) {
            switch (_context24.prev = _context24.next) {
              case 0:
                user = {
                  userId: '123',
                  username: 'username'
                };

                _AccountsServer2.default.config({}, {
                  findSessionById: function findSessionById() {
                    return Promise.resolve({
                      sessionId: '456',
                      valid: true,
                      userId: '123'
                    });
                  },
                  findUserById: function findUserById() {
                    return Promise.resolve(user);
                  }
                });
                _Accounts$instance$cr7 = _AccountsServer2.default.instance.createTokens('456'), accessToken = _Accounts$instance$cr7.accessToken;
                _context24.next = 5;
                return _AccountsServer2.default.resumeSession(accessToken);

              case 5:
                foundUser = _context24.sent;

                expect(foundUser).toEqual(user);

              case 7:
              case 'end':
                return _context24.stop();
            }
          }
        }, _callee24, undefined);
      })));
    });
    it('return user with custom validation method', _asyncToGenerator(regeneratorRuntime.mark(function _callee25() {
      var resumeSessionValidator, user, _Accounts$instance$cr8, accessToken;

      return regeneratorRuntime.wrap(function _callee25$(_context25) {
        while (1) {
          switch (_context25.prev = _context25.next) {
            case 0:
              resumeSessionValidator = jest.fn(function () {
                return Promise.resolve({});
              });
              user = {
                userId: '123',
                username: 'username'
              };

              _AccountsServer2.default.config({ resumeSessionValidator: resumeSessionValidator }, {
                findSessionById: function findSessionById() {
                  return Promise.resolve({
                    sessionId: '456',
                    valid: true,
                    userId: '123'
                  });
                },
                findUserById: function findUserById() {
                  return Promise.resolve(user);
                }
              });

              _Accounts$instance$cr8 = _AccountsServer2.default.instance.createTokens('456'), accessToken = _Accounts$instance$cr8.accessToken;
              _context25.next = 6;
              return _AccountsServer2.default.resumeSession(accessToken);

            case 6:

              expect(resumeSessionValidator.mock.calls.length).toBe(1);

            case 7:
            case 'end':
              return _context25.stop();
          }
        }
      }, _callee25, undefined);
    })));
    it('throw when custom validation method rejects', _asyncToGenerator(regeneratorRuntime.mark(function _callee26() {
      var resumeSessionValidator, user, _Accounts$instance$cr9, accessToken;

      return regeneratorRuntime.wrap(function _callee26$(_context26) {
        while (1) {
          switch (_context26.prev = _context26.next) {
            case 0:
              resumeSessionValidator = jest.fn(function () {
                return Promise.reject('Custom session error');
              });
              user = {
                userId: '123',
                username: 'username'
              };

              _AccountsServer2.default.config({ resumeSessionValidator: resumeSessionValidator }, {
                findSessionById: function findSessionById() {
                  return Promise.resolve({
                    sessionId: '456',
                    valid: true,
                    userId: '123'
                  });
                },
                findUserById: function findUserById() {
                  return Promise.resolve(user);
                }
              });

              _Accounts$instance$cr9 = _AccountsServer2.default.instance.createTokens('456'), accessToken = _Accounts$instance$cr9.accessToken;
              _context26.prev = 4;
              _context26.next = 7;
              return _AccountsServer2.default.resumeSession(accessToken);

            case 7:
              throw new Error();

            case 10:
              _context26.prev = 10;
              _context26.t0 = _context26['catch'](4);

              expect(resumeSessionValidator.mock.calls.length).toBe(1);
              expect(_context26.t0.message).toEqual('Custom session error');

            case 14:
            case 'end':
              return _context26.stop();
          }
        }
      }, _callee26, undefined, [[4, 10]]);
    })));
    describe('setProfile', function () {
      it('calls set profile on db interface', _asyncToGenerator(regeneratorRuntime.mark(function _callee27() {
        var user, profile, setProfile;
        return regeneratorRuntime.wrap(function _callee27$(_context27) {
          while (1) {
            switch (_context27.prev = _context27.next) {
              case 0:
                user = {
                  userId: '123',
                  username: 'username'
                };
                profile = {
                  bio: 'bio'
                };
                setProfile = jest.fn();

                _AccountsServer2.default.config({}, {
                  findUserById: function findUserById() {
                    return Promise.resolve(user);
                  },
                  setProfile: setProfile
                });
                _context27.next = 6;
                return _AccountsServer2.default.setProfile('123', profile);

              case 6:
                expect(setProfile.mock.calls.length).toEqual(1);
                expect(setProfile.mock.calls[0][0]).toEqual('123');
                expect(setProfile.mock.calls[0][1]).toEqual(profile);

              case 9:
              case 'end':
                return _context27.stop();
            }
          }
        }, _callee27, undefined);
      })));
      it('merges profile and calls set profile on db interface', _asyncToGenerator(regeneratorRuntime.mark(function _callee28() {
        var user, profile, mergedProfile, setProfile, res;
        return regeneratorRuntime.wrap(function _callee28$(_context28) {
          while (1) {
            switch (_context28.prev = _context28.next) {
              case 0:
                user = {
                  userId: '123',
                  username: 'username',
                  profile: {
                    title: 'title'
                  }
                };
                profile = {
                  bio: 'bio'
                };
                mergedProfile = {
                  title: 'title',
                  bio: 'bio'
                };
                setProfile = jest.fn(function () {
                  return mergedProfile;
                });

                _AccountsServer2.default.config({}, {
                  findUserById: function findUserById() {
                    return Promise.resolve(user);
                  },
                  setProfile: setProfile
                });
                _context28.next = 7;
                return _AccountsServer2.default.updateProfile('123', profile);

              case 7:
                res = _context28.sent;

                expect(setProfile.mock.calls.length).toEqual(1);
                expect(setProfile.mock.calls[0][0]).toEqual('123');
                expect(setProfile.mock.calls[0][1]).toEqual(mergedProfile);
                expect(res).toEqual(mergedProfile);

              case 12:
              case 'end':
                return _context28.stop();
            }
          }
        }, _callee28, undefined);
      })));
    });
  });
});